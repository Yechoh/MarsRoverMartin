/*
 * generated by Xtext 2.10.0
 */
package robot.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robot.dSL.ANDexpression;
import robot.dSL.Behaviors;
import robot.dSL.ColorLiteral;
import robot.dSL.DSLPackage;
import robot.dSL.DistanceLiteral;
import robot.dSL.ExpressionBracket;
import robot.dSL.LeftMovementAction;
import robot.dSL.MovementAction;
import robot.dSL.ORexpression;
import robot.dSL.RightMovementAction;
import robot.dSL.RobotBehavior;
import robot.dSL.RotateMovementAction;
import robot.dSL.TouchLiteral;
import robot.services.DSLGrammarAccess;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DSLPackage.AN_DEXPRESSION:
				sequence_Expression1(context, (ANDexpression) semanticObject); 
				return; 
			case DSLPackage.BEHAVIORS:
				sequence_Behaviors(context, (Behaviors) semanticObject); 
				return; 
			case DSLPackage.COLOR_LITERAL:
				sequence_ColorLiteral(context, (ColorLiteral) semanticObject); 
				return; 
			case DSLPackage.DISTANCE_LITERAL:
				sequence_DistanceLiteral(context, (DistanceLiteral) semanticObject); 
				return; 
			case DSLPackage.EXPRESSION_BRACKET:
				sequence_ExpressionBracket(context, (ExpressionBracket) semanticObject); 
				return; 
			case DSLPackage.LEFT_MOVEMENT_ACTION:
				sequence_LeftMovementAction(context, (LeftMovementAction) semanticObject); 
				return; 
			case DSLPackage.MOVEMENT_ACTION:
				sequence_MovementAction(context, (MovementAction) semanticObject); 
				return; 
			case DSLPackage.OREXPRESSION:
				sequence_Expression2(context, (ORexpression) semanticObject); 
				return; 
			case DSLPackage.RIGHT_MOVEMENT_ACTION:
				sequence_RightMovementAction(context, (RightMovementAction) semanticObject); 
				return; 
			case DSLPackage.ROBOT_BEHAVIOR:
				sequence_RobotBehavior(context, (RobotBehavior) semanticObject); 
				return; 
			case DSLPackage.ROTATE_MOVEMENT_ACTION:
				sequence_RotateMovementAction(context, (RotateMovementAction) semanticObject); 
				return; 
			case DSLPackage.TOUCH_LITERAL:
				sequence_TouchLiteral(context, (TouchLiteral) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Behaviors returns Behaviors
	 *
	 * Constraint:
	 *     (name=ID sensorExpression=Expression actionlist+=Actions+)
	 */
	protected void sequence_Behaviors(ISerializationContext context, Behaviors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ColorLiteral
	 *     Expression1 returns ColorLiteral
	 *     Expression1.ANDexpression_1_0 returns ColorLiteral
	 *     Expression2 returns ColorLiteral
	 *     Expression2.ORexpression_1_0 returns ColorLiteral
	 *     Expression3 returns ColorLiteral
	 *     ColorLiteral returns ColorLiteral
	 *
	 * Constraint:
	 *     color=ColorEnum
	 */
	protected void sequence_ColorLiteral(ISerializationContext context, ColorLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.COLOR_LITERAL__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.COLOR_LITERAL__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorLiteralAccess().getColorColorEnumEnumRuleCall_1_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DistanceLiteral
	 *     Expression1 returns DistanceLiteral
	 *     Expression1.ANDexpression_1_0 returns DistanceLiteral
	 *     Expression2 returns DistanceLiteral
	 *     Expression2.ORexpression_1_0 returns DistanceLiteral
	 *     Expression3 returns DistanceLiteral
	 *     DistanceLiteral returns DistanceLiteral
	 *
	 * Constraint:
	 *     distance=INT
	 */
	protected void sequence_DistanceLiteral(ISerializationContext context, DistanceLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.DISTANCE_LITERAL__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.DISTANCE_LITERAL__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDistanceLiteralAccess().getDistanceINTTerminalRuleCall_1_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ANDexpression
	 *     Expression1 returns ANDexpression
	 *     Expression1.ANDexpression_1_0 returns ANDexpression
	 *
	 * Constraint:
	 *     (left=Expression1_ANDexpression_1_0 right=Expression2)
	 */
	protected void sequence_Expression1(ISerializationContext context, ANDexpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.AN_DEXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression1Access().getANDexpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression1Access().getRightExpression2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ORexpression
	 *     Expression1 returns ORexpression
	 *     Expression1.ANDexpression_1_0 returns ORexpression
	 *     Expression2 returns ORexpression
	 *     Expression2.ORexpression_1_0 returns ORexpression
	 *
	 * Constraint:
	 *     (left=Expression2_ORexpression_1_0 right=Expression3)
	 */
	protected void sequence_Expression2(ISerializationContext context, ORexpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.OREXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.OREXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.OREXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.OREXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression2Access().getORexpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression2Access().getRightExpression3ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionBracket
	 *     Expression1 returns ExpressionBracket
	 *     Expression1.ANDexpression_1_0 returns ExpressionBracket
	 *     Expression2 returns ExpressionBracket
	 *     Expression2.ORexpression_1_0 returns ExpressionBracket
	 *     Expression3 returns ExpressionBracket
	 *     ExpressionBracket returns ExpressionBracket
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_ExpressionBracket(ISerializationContext context, ExpressionBracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.EXPRESSION_BRACKET__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.EXPRESSION_BRACKET__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionBracketAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns LeftMovementAction
	 *     LeftMovementAction returns LeftMovementAction
	 *
	 * Constraint:
	 *     leftmove=MovementAction
	 */
	protected void sequence_LeftMovementAction(ISerializationContext context, LeftMovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.LEFT_MOVEMENT_ACTION__LEFTMOVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.LEFT_MOVEMENT_ACTION__LEFTMOVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftMovementActionAccess().getLeftmoveMovementActionParserRuleCall_1_0(), semanticObject.getLeftmove());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MovementAction returns MovementAction
	 *
	 * Constraint:
	 *     actionenum=ActionEnum
	 */
	protected void sequence_MovementAction(ISerializationContext context, MovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.MOVEMENT_ACTION__ACTIONENUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.MOVEMENT_ACTION__ACTIONENUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMovementActionAccess().getActionenumActionEnumEnumRuleCall_0(), semanticObject.getActionenum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns RightMovementAction
	 *     RightMovementAction returns RightMovementAction
	 *
	 * Constraint:
	 *     rightmove=MovementAction
	 */
	protected void sequence_RightMovementAction(ISerializationContext context, RightMovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.RIGHT_MOVEMENT_ACTION__RIGHTMOVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.RIGHT_MOVEMENT_ACTION__RIGHTMOVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightMovementActionAccess().getRightmoveMovementActionParserRuleCall_1_0(), semanticObject.getRightmove());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RobotBehavior returns RobotBehavior
	 *
	 * Constraint:
	 *     behaviorlist+=Behaviors+
	 */
	protected void sequence_RobotBehavior(ISerializationContext context, RobotBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actions returns RotateMovementAction
	 *     RotateMovementAction returns RotateMovementAction
	 *
	 * Constraint:
	 *     (rotateleft=INT leftdir=RotateEnum rotateright=INT rightdir=RotateEnum)
	 */
	protected void sequence_RotateMovementAction(ISerializationContext context, RotateMovementAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__ROTATELEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__ROTATELEFT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__LEFTDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__LEFTDIR));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__ROTATERIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__ROTATERIGHT));
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__RIGHTDIR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.ROTATE_MOVEMENT_ACTION__RIGHTDIR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getRotateleftINTTerminalRuleCall_1_0(), semanticObject.getRotateleft());
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getLeftdirRotateEnumEnumRuleCall_2_0(), semanticObject.getLeftdir());
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getRotaterightINTTerminalRuleCall_3_0(), semanticObject.getRotateright());
		feeder.accept(grammarAccess.getRotateMovementActionAccess().getRightdirRotateEnumEnumRuleCall_4_0(), semanticObject.getRightdir());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TouchLiteral
	 *     Expression1 returns TouchLiteral
	 *     Expression1.ANDexpression_1_0 returns TouchLiteral
	 *     Expression2 returns TouchLiteral
	 *     Expression2.ORexpression_1_0 returns TouchLiteral
	 *     Expression3 returns TouchLiteral
	 *     TouchLiteral returns TouchLiteral
	 *
	 * Constraint:
	 *     touch=TouchEnum
	 */
	protected void sequence_TouchLiteral(ISerializationContext context, TouchLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DSLPackage.Literals.TOUCH_LITERAL__TOUCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DSLPackage.Literals.TOUCH_LITERAL__TOUCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTouchLiteralAccess().getTouchTouchEnumEnumRuleCall_1_0(), semanticObject.getTouch());
		feeder.finish();
	}
	
	
}
